## design-patterns-in-golang

![](https://raw.githubusercontent.com/ismayilmalik/golang-design-patterns/master/logo.png)

[菜鸟教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)


## 设计模式的七大原则
1、开闭原则（Open Close Principle）

开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

2、里氏代换原则（Liskov Substitution Principle）

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

3、依赖倒转原则（Dependence Inversion Principle）

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

4、接口隔离原则（Interface Segregation Principle）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

5、迪米特法则，又称最少知道原则（Demeter Principle）

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6、合成复用原则（Composite Reuse Principle）

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承

7、单一职责原则（Simple Responsibility Principle, SRP）

指不要存在一个以上导致类变更的原因。假设有一个Class负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。


### 创建型模式分类

- [x] 单例模式

确保类只有一个实例，并提供对它的全局访问点。

- [x] 原型模式

指定使用原型实例创建的对象类型，并通过复制此原型创建新对象。

- [x] 工厂方法模式

定义用于创建对象的接口，但让子类决定实例化哪个类。工厂方法让类延迟实例化到子类。

- [x] 抽象工厂模式

提供一个接口，用于创建一系列相关或依赖的对象，而无需指定它们的具体类。

- [x] 建造者模式

将复杂对象的构造与其表示分离，以便相同的构造过程可以创建不同的表示。


### 结构型模式概述

- [x] 代理模式

一个类代表另一个类的功能，为其他对象提供一种代理以控制对这个对象的访问

- [x] 适配器模式

将类的接口转换为客户端期望的另一个接口。适配器使由于接口不兼容而无法在一起工作的类能够一起工作。

- [x] 桥接模式

将一个抽象从它的实现中解耦，这样两者可以独立地变化。

- [x] 装饰模式

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活

- [x] 外观模式

为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

- [x] 享元模式

容器对象技术（IOC），用于减少创建对象的数量，以减少内存占用和提高性能，运用共享技术有效地支持大量细粒度的对象。

- [x] 组合模式

将对象组合成树结构来表示部分-整体层次结构。复合让客户端统一地对待单个对象和对象的组合。

### 行为型模式概述

- [x] 模板方法模式

在操作中定义算法的框架，将一些步骤延迟到子类。模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤。

- [x] 策略模式

定义一系列算法，封装每一个算法，并使它们可互换。策略让算法独立于使用它的客户而变化。

- [x] 命令模式

将请求封装为对象，从而使您可以用不同的请求对客户机进行参数化，并支持可撤消的操作。

- [x] 责任链模式

通过给多个对象一个处理请求的机会，避免将请求的发送者耦合到其接收者。链接接收对象，并将请求沿着链传递，直到对象处理该请求。

- [x] 状态模式

允许对象在其内部状态改变时改变其行为。对象将在更改其类时出现

- [x] 观察者模式

定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖关系都会被自动通知和更新

- [x] 中介者模式

定义封装一组对象如何交互的对象。中介通过防止对象显式地相互引用来促进松耦合，并且它允许您独立地改变它们的交互

- [x] 迭代器模式

提供按顺序访问聚合对象的元素而不公开其底层表示的方法。

- [x] 访问者模式

表示要在对象结构的元素上执行的操作。Visitor允许您定义新的操作，而无需更改操作的元素的类

- [x] 备忘录模式

在不违反封装的情况下，捕获并外部化对象的内部状态，以便稍后可以将对象恢复到此状态。

- [x] 解释器模式

给定一种语言，为其语法定义一种表示，以及使用该表示来解释该语言中的句子的解释器。